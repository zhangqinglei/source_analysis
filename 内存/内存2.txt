

1.方法区、虚拟机栈、本地方法栈、堆、程序计数器.
2. 程序计数器是正在执行的虚拟机字节码指令地址， 如果是native方法， 计数器为空。 
   唯一一个没有规定OutOfMemmortError的内存区域.
3. 虚拟机栈， 本地方法栈，程序计数器是线程私有的。 方法区，堆是线程共有的。
4. 每个方法创建都会创建一个栈帧，用于存储局部变量，操作数栈，动态链接方法出口等信息。
   本地栈和虚拟机栈都会抛出StackOverFlowError和OutOfMemmeoyError。
   
5. Java堆分为新生代和老年代
   新生代分为Enden 和From Survior1和 To Survior.
   大小可以通过-Xmx -Xms控制。 如果堆内没有完成内存分配且无法拓展，将会抛出OutOfMemmeoryError异常。
   
6. 方法区用于存储类信息，常量(final变量), 静态变量，即使编译信息。 方法区（永久代有XX:MaxPermSize限制）。
   方法区的内存回收主要在于类型卸载和常量池回收。
7. 常量池用于存放编译期生成的字面符号量(int a = 20 20是字面量)，和符号引用。常量池无法再申请时会抛出
   OutOfMemeoryError异常。
   
8. 虚拟机遇到 New指令时会首先加载这个指令是否在常量池中定位到一个类的引用，并检这个引用代表的类是否
   已经加载，解析初始化。如果没有则执行加载过程。
9. 对象分配后除对象头之外初始化为0. New指令执行后会跟随<init>方法执行进行类的初始化 。

10. 对象头包括两部分，一哈希码(hasnCode), GC分代年龄，锁状态标志， 线程持有的锁， 偏向线程 ID.

11. -Xss设置方法栈的大小。
12. 垃圾回收算法
    1. 标记-清除 容易产生大量不连续的碎片， 在分配较大内存时无法找到足够的连续内存导致触发新的垃圾搜集动作
	2. 复制算法  将存活的对象复制到另一半， 简单高效。 但是利用效率低。
	3. 标记-整理算法
	4. 分代收集。 新生代老年代
	
13. Serial收集器： 垃圾回收时必须挂起所有线程。 运行在Client模式下。简单高效。
14. 
	
	 