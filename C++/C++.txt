
1. 结构体struct：把不同类型的数据组合成一个整体，自定义类型。
   共同体union：使几个不同类型的变量共同占用一段内存。
   struct和union都有内存对齐，结构体的内存布局依赖于CPU、操作系统、编译器及编译时的对齐选项
   1.数据类型自身的对齐值：
     对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，单位字节。
   2.结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。
   3.指定对齐值：#pragma pack(n)，n=1,2,4,8,16改变系统的对齐系数
   4.数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。
   
2. 常见数据类型及其长度：
   注意long int和int一样是4byte，long double和double一样是8byte。
3. 在标准c++中，int的定义长度要依靠你的机器的字长，也就是说，如果你的机器是32位的，int的长度为32位，
   如果你的机器是64位的，那么int的标准长度就是64位
   
   结构体struct：不同之处，stuct里每个成员都有自己独立的地址。sizeof(struct)是内存对齐后所有成员长度的加和。
   共同体union：当共同体中存入新的数据后，原有的成员就失去了作用，新的数据被写到union的地址中。
   sizeof(union)是最长的数据成员的长度。
4. static 和const分别怎么用，类里面static和const可以同时修饰成员函数吗。
    
   1.局部变量：
   在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。	
   1）内存中的位置：静态存储区
   2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）
   3）作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。
   当static用来修饰局部变量的时候，它就改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期
   （局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进
   行访问），但未改变其作用域。
   
   2.全局变量
   在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。
   1）内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）
   2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）
   3）作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。
   static修饰全局变量，并为改变其存储位置及生命周期，而是改变了其作用域，使当前文件外的源文件无法访问该变量，
   好处如下：
   （1）不会被其他文件所访问，修改
   （2）其他文件中可以使用相同名字的变量，不会发生冲突。对全局函数也是有隐藏作用。
   
   3.静态成员变量
     用static修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，包括派生类的对象。因此，static
	 成员必须在类外进行初始化(初始化格式： int base::var=10;)，而不能在构造函数内进行初始化，不过也可以用
	 const修饰static数据成员在类内初始化 。
	 
	 (1)不要试图在头文件中定义(初始化)静态数据成员。在大多数的情况下，这样做会引起重复定义这样的错误。即使加
	    上#ifndef #define #endif或者#pragma once也不行。 
     (2)静态数据成员可以成为成员函数的可选参数，而普通数据成员则不可以。
	 (3)静态数据成员的类型可以是所属类的类型，而普通数据成员则不可以。普通数据成员的只能声明为 所属类类型的指针或引用。
	 (4)用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针
	 (5)静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。base::func(5,3);当static成员函数在
	    类外定义时不需要加static修饰符。
	 (6)在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。因为静态成员函数不含this指针。 
	 
5. 不可以同时用const和static修饰成员函数。
   C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。
   但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。
   static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状
   态，与类型的静态变量没有关系
		
6. const的作用：
   1.限定变量为不可修改。
   2.限定成员函数不可以修改任何数据成员。
   3.const与指针：
     const char *p 表示 指向的内容不能改变。
	 char * const p，就是将P声明为常指针，它的地址不能改变，是固定的，但是它的内容可以改变。
	 
7. 指针和引用的区别，引用可以用常指针实现吗
   本质上的区别是，指针是一个新的变量，只是这个变量存储的是另一个变量的地址，我们通过访问这个地址来修改变量。
   而引用只是一个别名，还是变量本身。对引用进行的任何操作就是对变量本身进行操作，因此以达到修改变量的目的。
   (2)可以有const指针，但是没有const引用；
   (3)指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）
   (4)指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；
   (5)指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。
   (6)"sizeof引用"得到的是所指向的变量(对象)的大小，而"sizeof指针"得到的是指针本身的大小；
   (7)指针和引用的自增(++)运算意义不一样；
   
8. 什么是多态，多态有什么用途。
   定义：“一个接口，多种方法”，程序在运行时才决定调用的函数。
   实现：C++多态性主要是通过虚函数实现的，虚函数允许子类重写override(注意和overload的区别，overload是重载，
         是允许同名函数的表现，这些函数参数列表/类型不同）。
   目的：接口重用。封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态
         的目的则是为了接口重用	 
9. Overload(重载)：在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型、顺序不同），即函数重载。
  （1）相同的范围（在同一个类中）；
  （2）函数名字相同；
  （3）参数不同；
  （4）virtual 关键字可有可无。
10. Override(覆盖)：是指派生类函数覆盖基类函数，特征是：
  （1）不同的范围（分别位于派生类与基类）；
  （2）函数名字相同；
  （3）参数相同；
  （4）基类函数必须有virtual 关键字。
  
11. map和set的底层实现主要是由红黑树实现的。

12. 多态分为编译时多态和运行时多态
    编译时多态是由重载来实现的，运行时多态是由接口实现的
	
13. 指向常量的指针 : const char* p;
    常指针 char* const p;
	指向常量的常指针 const char* const p;
	
14.局部变量在其作用域内有较高的优先权。
  
15. new和malloc的区别
	new能够自动计算所要分配内存类型的大小，
	new能够自动返回正确的指针类型，不比对返回的指针转化
	new可以对对象初始化
	new和delete都可以被重载，允许自定义内存管理方法
    malloc 需要手动计算类型的大小。
	
16. 内存分配的三种方式：
   从静态存储区分配。数据的内存在程序编译时已经被分配，该内存在整个运行期间长期驻留，
   不会被释放；程序结束时，由操作系统自动释放。这类数据包括静态数据和全局数据。
   从栈空间分配。函数执行过程中，函数中的局部变量的内存，在栈上被分配；当函数调用完
   成后，随函数的返回空间也被释放。
   从堆空间分配。由开发者动态的申请内存，并手动的释放内存。
   
17. 引用
    引用必须声明时初始化，
	引用不能重新赋值
	不能声明引用数组&arr[]
	不能声明引用的医用&&
	函数返回引用，函数内部的局部变量不能返回，因为函数结束后局部变量的生命周期也结束了。
	
18. 类
    (1)在类生命是不能赋值， 只有在对象定义之后才能给成员赋值
    (2)析构函数不能重载只能重写。对象撤销时会自动调用析构函数	
	(3)C++默认生成的函数构造函数，析构函数和拷贝构造函数。
	(4)静态数据成员初始化是在类外进行的，静态数据成员是编译时初始化的。
	(5)静态成员函数用来访问全局变量和同一个类中的静态变量。
	(6)一般成员函数隐试含有this指针，静态函数没有
	(7)静态函数不能访问非静态成员。
	(8)基类没有构造函数，之类可以不定义构造函数，如果基类有构造函数子类必须定义构造函数。
	
  
   
		
		
		
		
		
		
		
		
		
		
		
		
	 