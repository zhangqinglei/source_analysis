1. 一个java文件中可以有多个类，但只能有一个public的类
2. &、&&都可以作为逻辑与, &还可以作为位运算。
3. short s1 = 1; s1 = s1 + 1;有错，会被编译器警告 编译器将报告需要强制转换类型的错误。
   对于short s1 = 1; s1 += 1;由于 +=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。
4. unicode编码占用两个字节，所以，char类型的变量也是占用两个字节 ， 所以char也可以保存汉字。
5. 使用final关键字修饰一个变量时，引用不能变  
6. 静态变量前要加static关键字，而实例变量前则不加。
7. if(username.equals(“zxx”){}不合理， username有可能为null，导致NullPointException
8. return x==1?true:false; 这个改成return x==1;就可以!
9. 如果在修饰的元素上面没有写任何访问修饰符，则表示friendly。
10. Overload是重载的意思，Override是覆盖的意思，也就是重写。
11. 重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，
    将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现
12. 构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload。
13. 接口只能通过extends继承接口
16. 接口可以继承接口。抽象类可以实现(implements)接口，抽象类可以继承具体类。抽象类中可以有静态的main方法。
17. 抽象类继承接口可以不用实现接口定义的方法
18. 封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的“高内聚、低耦合，防止程序相互依赖性而带来的变动影响。	
19. Java中的多态实现机制靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象
20. 接口和抽象类的区别
    (1)抽象类有构造函数，接口没有，
	(2)抽象类有普通变量， 接口没有
	(3)抽象类中有普通方法，接口中没有
	(4)抽象类可以访问的类型有public. protected和默认类型，接口必须为public
	(5)抽象类中包含静态方法，接口中没有
    (6)抽象类和接口中都可以有静态变量，但是接口是final类型	
21. 抽象方法不能是静态方法或native方法， 因为抽象方法必须由子类实现，‘
22. 内部类不允许定义静态变量， 内部类必须外部类实例化才能实例化。
23. 内部类可以访问外部类的所有变量，内部类可以定义在外部类的方法的里面，也可以定义在外部类的方法外面。
     方法体内定义的内部类不能有修饰符(public, protected), 但是可以abstract, final;
	 
24. 在方法外部定义的内部类前面可以加上static关键字，从而成为Static Nested Class，它不再具有内部类的特性
    它可以定义成public、protected、默认的、private等多种类型，而普通类只能定义成public和默认的这两种类型。
	在外面引用Static Nested Class类的名称为“外部类名.内部类名”。	
	
25. static Nested Class能访问外部类的非static成员变量(不能直接访问，需要创建外部类实例才能访问非静态变量)。
    在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字
	
26. 匿名类必须继承类或接口。
27. String类是final类故不可以继承。
28. String s = new String("xyz");创建了几个String Object?
    创建了两个。一个是String s, l另一个是new String("xyz")， S指向想创建的对象.
29. final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。
    内部类要访问局部变量，局部变量必须定义成final类型 (Andrid 里重写Handler，访问变量)
	finally是异常处理语句结构的一部分，表示总是执行。
30. finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，
    可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用	
31. throws捕获并向外抛出异常
	throw抛出异常
	try catch是内部捕获异常并做自定义处理
	finally是无论是否有异常都会被处理的语句，除非在finally前存在被执行的
32. 简述synchronized和java.util.concurrent.locks.Lock的异同？
    主要相同点：Lock能完成synchronized所实现的所有功能
	主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，
	并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。
33. JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader是一个重要的Java运行时系统组件。
    它负责在运行时查找和装入类文件的类。	
34. Java的内存分为两类，一类是栈内存，一类是堆内存。栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，
    用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。
35. 堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用new创建的对象都放在堆里，所以，
    它不会随方法的结束而消失。(方法中的局部变量使用final修饰后，放在堆中，而不是栈中)
36. GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，
    哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间	
37. 程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。
38. 所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中
39. java中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，
    但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景
40. 从来没有人说过Java的Class名字必须和其文件名相同。但public class的名字必须和文件名相同。	

























	
	
	
	
	
	
	
	

	
