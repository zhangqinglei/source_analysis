
1. ArrayBlockingQueue类
   this.items = new Object[capacity];
   lock = new ReentrantLock(fair);
   notEmpty = lock.newCondition();
   notFull =  lock.newCondition();
   
2. ArrayBlockingQueue.offer(T t)
   public boolean offer(E e) {
        Objects.requireNonNull(e);
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            if (count == items.length)
                return false;
            else {
                enqueue(e);
                return true;
            }
        } finally {
            lock.unlock();
        }
    }
	
	1.获取重新入锁
	2.如果队列达到上限返回false
	3.没有达到上限加入队列, 添加成功返回True
	
	
3. ArrayBlockingQueue.add(T t)
   就是调用offer()函数，如果如果返回true添加成功，否则，抛出异常
   throw new IllegalStateException("Queue full");。
   
4. ArrayBlockingQueue.poll()
   获取重入锁， 如果没有返回null
   
5. ArrayBlockingQueue.take() 
   public E take() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == 0)
                notEmpty.await();
            return dequeue();
        } finally {
            lock.unlock();
        }
    }
	
	如果队列的长度为0 则等待。
	
6. LinkedBlockingQueue类
   内部由Node创建链表
   
7. LinkedBlockingQueue.offer(E e)
   获取重新入锁，在队尾插入节点
   
 
8. LinkedBlockingQueue.add(E e)
   调用offerLast()方法，如果添加失败就抛出异常
   
9. LinkedBlockingQueue.put(E e)
   获取重新入锁，在队尾插入节点,如果插入失败就等待。
     
   

















	
	